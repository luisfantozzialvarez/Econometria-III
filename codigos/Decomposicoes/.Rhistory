det = 0.01*0:500 + rb
plot(ts(det,start=0))
#Simulando ARMA(1,2)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
#Função para simular um processo da forma
#Y_t = alpha + rho*y_{t-1} + epsilon_t
#onde epsilon_t ~ N(0, sigma^2) iid
#Se |rho| < 1, processo é inicializado como y_0 ~ N(alpha/(1-rho), sigma^2/(1-rho^2))
#do contrário, processo inicia em alpha.
ar.sim <- function(Nperiods, rho, alpha = 0, sigma = 1)
{
if(abs(rho)<1)
y = rnorm(1, alpha/(1-rho), sd = sigma/sqrt(1-rho^2)) else y = alpha
epsilon = rnorm(Nperiods, mean = 0, sd = sigma)
for(j in 1:Nperiods)
y = c(y, alpha + rho*y[j] + epsilon[j])
return(y)
}
#Função para simular um MA(q) Gaussiano. O comprimento do vetor q determina a ordem do MA
ma.sim <- function(Nperiods, psi = c(), alpha = 0, sigma = 1)
{
noise = rnorm(Nperiods+length(psi), sd = sigma)
vec_lg = sapply(0:length(psi), function(x){
noise[(length(psi)-x+1):(length(noise)-x)]
})
mov = as.numeric(vec_lg%*%c(1,psi))
}
#Fixa semente do simulador - para replicar resultados
set.seed(13579)
#Simulando ruído branco
rb = ts(ar.sim(500, rho = 0), start=0)
plot(rb)
#Simulando AR1
ar1 = ts(ar.sim(500, rho = 0.7), start=0)
plot(ar1)
#Simulando MA2
#Vamos usar a função arima.sim, do pacote stats (carregando, por padrão, no R)
ma2 = ts(ma.sim( 500, psi = c(1,0.5) ),start = 0)
plot(ma2)
#Simulando ARMA(1,2)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
plot(arma12)
#Processo determinístico
det = 0.01*0:500 + rb
plot(ts(det,start=0))
#Passeio aleatorio
rw = ts(ar.sim(500, rho=1), start = 0)
plot(rw)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,-0.5) ),n = 500),start= 0)
plot(arma12)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(-1,0.5) ),n = 500),start= 0)
plot(arma12)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
plot(arma12)
#Função para simular um processo da forma
#Y_t = alpha + rho*y_{t-1} + epsilon_t
#onde epsilon_t ~ N(0, sigma^2) iid
#Se |rho| < 1, processo é inicializado como y_0 ~ N(alpha/(1-rho), sigma^2/(1-rho^2))
#do contrário, processo inicia em alpha.
ar.sim <- function(Nperiods, rho, alpha = 0, sigma = 1)
{
if(abs(rho)<1)
y = rnorm(1, alpha/(1-rho), sd = sigma/sqrt(1-rho^2)) else y = alpha
epsilon = rnorm(Nperiods, mean = 0, sd = sigma)
for(j in 1:Nperiods)
y = c(y, alpha + rho*y[j] + epsilon[j])
return(y)
}
#Função para simular um MA(q) Gaussiano. O comprimento do vetor q determina a ordem do MA
ma.sim <- function(Nperiods, psi = c(), alpha = 0, sigma = 1)
{
noise = rnorm(Nperiods+length(psi), sd = sigma)
vec_lg = sapply(0:length(psi), function(x){
noise[(length(psi)-x+1):(length(noise)-x)]
})
mov = as.numeric(vec_lg%*%c(1,psi))
}
#Fixa semente do simulador - para replicar resultados
set.seed(13579)
#Simulando ruído branco
rb = ts(ar.sim(500, rho = 0), start=0)
plot(rb)
#Simulando AR1
ar1 = ts(ar.sim(500, rho = 0.7), start=0)
plot(ar1)
#Simulando MA2
#Vamos usar a função arima.sim, do pacote stats (carregando, por padrão, no R)
ma2 = ts(ma.sim( 500, psi = c(1,0.5) ),start = 0)
plot(ma2)
#Simulando ARMA(1,2)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
plot(arma12)
#Processo determinístico
det = 0.01*0:500 + rb
plot(ts(det,start=0))
#Passeio aleatorio
rw = ts(ar.sim(500, rho=1), start = 0)
plot(rw)
mean_break = ts(c(ar.sim(500, rho=0), 1+ar.sim(500, rho=0)), start = 0)
mean_break = ts(c(ar.sim(250, rho=0), 1+ar.sim(250, rho=0)), start = 0)
plot(mean_break)
mean_break = ts(c(ar.sim(250, rho=0), 2+ar.sim(250, rho=0)), start = 0)
plot(mean_break)
sd_break = ts(c(ar.sim(250, rho=0), sqrt(2)*ar.sim(250, rho=0)), start = 0)
plot(sd_break)
sd_break = ts(c(ar.sim(250, rho=0), 2*ar.sim(250, rho=0)), start = 0)
plot(sd_break)
#Função para simular um processo da forma
#Y_t = alpha + rho*y_{t-1} + epsilon_t
#onde epsilon_t ~ N(0, sigma^2) iid
#Se |rho| < 1, processo é inicializado como y_0 ~ N(alpha/(1-rho), sigma^2/(1-rho^2))
#do contrário, processo inicia em alpha.
ar.sim <- function(Nperiods, rho, alpha = 0, sigma = 1)
{
if(abs(rho)<1)
y = rnorm(1, alpha/(1-rho), sd = sigma/sqrt(1-rho^2)) else y = alpha
epsilon = rnorm(Nperiods, mean = 0, sd = sigma)
for(j in 1:Nperiods)
y = c(y, alpha + rho*y[j] + epsilon[j])
return(y)
}
#Função para simular um MA(q) Gaussiano. O comprimento do vetor q determina a ordem do MA
ma.sim <- function(Nperiods, psi = c(), alpha = 0, sigma = 1)
{
noise = rnorm(Nperiods+length(psi), sd = sigma)
vec_lg = sapply(0:length(psi), function(x){
noise[(length(psi)-x+1):(length(noise)-x)]
})
mov = as.numeric(vec_lg%*%c(1,psi))
}
#Fixa semente do simulador - para replicar resultados
set.seed(13579)
#Simulando ruído branco
rb = ts(ar.sim(500, rho = 0), start=0)
plot(rb)
#Simulando AR1
ar1 = ts(ar.sim(500, rho = 0.7), start=0)
plot(ar1)
#Simulando MA2
#Vamos usar a função arima.sim, do pacote stats (carregando, por padrão, no R)
ma2 = ts(ma.sim( 500, psi = c(1,0.5) ),start = 0)
plot(ma2)
#Simulando ARMA(1,2)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
plot(arma12)
#Processo determinístico
det = 0.01*0:500 + rb
plot(ts(det,start=0))
#Passeio aleatorio
rw = ts(ar.sim(500, rho=1), start = 0)
plot(rw)
#Quebra de média
mean_break = ts(c(ar.sim(250, rho=0), 2+ar.sim(250, rho=0)), start = 0)
plot(mean_break)
#Quebra da variância
sd_break = ts(c(ar.sim(250, rho=0), sqrt(2)*ar.sim(250, rho=0)), start = 0)
plot(sd_break)
#Função para simular um processo da forma
#Y_t = alpha + rho*y_{t-1} + epsilon_t
#onde epsilon_t ~ N(0, sigma^2) iid
#Se |rho| < 1, processo é inicializado como y_0 ~ N(alpha/(1-rho), sigma^2/(1-rho^2))
#do contrário, processo inicia em alpha.
ar.sim <- function(Nperiods, rho, alpha = 0, sigma = 1)
{
if(abs(rho)<1)
y = rnorm(1, alpha/(1-rho), sd = sigma/sqrt(1-rho^2)) else y = alpha
epsilon = rnorm(Nperiods, mean = 0, sd = sigma)
for(j in 1:Nperiods)
y = c(y, alpha + rho*y[j] + epsilon[j])
return(y)
}
#Função para simular um MA(q) Gaussiano. O comprimento do vetor q determina a ordem do MA
ma.sim <- function(Nperiods, psi = c(), alpha = 0, sigma = 1)
{
noise = rnorm(Nperiods+length(psi), sd = sigma)
vec_lg = sapply(0:length(psi), function(x){
noise[(length(psi)-x+1):(length(noise)-x)]
})
mov = as.numeric(vec_lg%*%c(1,psi))
}
#Fixa semente do simulador - para replicar resultados
set.seed(13579)
#Simulando ruído branco
rb = ts(ar.sim(500, rho = 0), start=0)
plot(rb)
#Simulando AR1
ar1 = ts(ar.sim(500, rho = 0.7), start=0)
plot(ar1)
#Simulando MA2
#Vamos usar a função arima.sim, do pacote stats (carregando, por padrão, no R)
ma2 = ts(ma.sim( 500, psi = c(1,0.5) ),start = 0)
plot(ma2)
#Simulando ARMA(1,2)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
plot(arma12)
#Processo determinístico
det = 0.01*0:500 + rb
plot(ts(det,start=0))
#Passeio aleatorio
rw = ts(ar.sim(500, rho=1), start = 0)
plot(rw)
#Quebra de média
mean_break = ts(c(ar.sim(250, rho=0), 2+ar.sim(250, rho=0)), start = 0)
plot(mean_break)
#Quebra da variância
sd_break = ts(c(ar.sim(250, rho=0), sqrt(4)*ar.sim(250, rho=0)), start = 0)
plot(sd_break)
break_mean = ts(c(ar.sim(250, rho=0),2+ar.sim(250,rho=0)), start = 0)
#Função para simular um processo da forma
#Y_t = alpha + rho*y_{t-1} + epsilon_t
#onde epsilon_t ~ N(0, sigma^2) iid
#Se |rho| < 1, processo é inicializado como y_0 ~ N(alpha/(1-rho), sigma^2/(1-rho^2))
#do contrário, processo inicia em alpha.
ar.sim <- function(Nperiods, rho, alpha = 0, sigma = 1)
{
if(abs(rho)<1)
y = rnorm(1, alpha/(1-rho), sd = sigma/sqrt(1-rho^2)) else y = alpha
epsilon = rnorm(Nperiods, mean = 0, sd = sigma)
for(j in 1:Nperiods)
y = c(y, alpha + rho*y[j] + epsilon[j])
return(y)
}
#Função para simular um MA(q) Gaussiano. O comprimento do vetor q determina a ordem do MA
ma.sim <- function(Nperiods, psi = c(), alpha = 0, sigma = 1)
{
noise = rnorm(Nperiods+length(psi), sd = sigma)
vec_lg = sapply(0:length(psi), function(x){
noise[(length(psi)-x+1):(length(noise)-x)]
})
mov = as.numeric(vec_lg%*%c(1,psi))
}
#Fixa semente do simulador - para replicar resultados
set.seed(13579)
#Simulando ruído branco
rb = ts(ar.sim(500, rho = 0), start=0)
plot(rb)
#Simulando AR1
ar1 = ts(ar.sim(500, rho = 0.7), start=0)
plot(ar1)
#Simulando MA2
#Vamos usar a função arima.sim, do pacote stats (carregando, por padrão, no R)
ma2 = ts(ma.sim( 500, psi = c(1,0.5) ),start = 0)
plot(ma2)
#Simulando ARMA(1,2)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
plot(arma12)
#Processo determinístico
det = 0.01*0:500 + rb
plot(ts(det,start=0))
#Passeio aleatorio
rw = ts(ar.sim(500, rho=1), start = 0)
plot(rw)
#Quebra de média
break_mean = ts(c(ar.sim(250, rho=0),2+ar.sim(250,rho=0)), start = 0)
plot(break_mean)
#Função para simular um processo da forma
#Y_t = alpha + rho*y_{t-1} + epsilon_t
#onde epsilon_t ~ N(0, sigma^2) iid
#Se |rho| < 1, processo é inicializado como y_0 ~ N(alpha/(1-rho), sigma^2/(1-rho^2))
#do contrário, processo inicia em alpha.
ar.sim <- function(Nperiods, rho, alpha = 0, sigma = 1)
{
if(abs(rho)<1)
y = rnorm(1, alpha/(1-rho), sd = sigma/sqrt(1-rho^2)) else y = alpha
epsilon = rnorm(Nperiods, mean = 0, sd = sigma)
for(j in 1:Nperiods)
y = c(y, alpha + rho*y[j] + epsilon[j])
return(y)
}
#Função para simular um MA(q) Gaussiano. O comprimento do vetor q determina a ordem do MA
ma.sim <- function(Nperiods, psi = c(), alpha = 0, sigma = 1)
{
noise = rnorm(Nperiods+length(psi), sd = sigma)
vec_lg = sapply(0:length(psi), function(x){
noise[(length(psi)-x+1):(length(noise)-x)]
})
mov = as.numeric(vec_lg%*%c(1,psi))
}
#Fixa semente do simulador - para replicar resultados
set.seed(13579)
#Simulando ruído branco
rb = ts(ar.sim(500, rho = 0), start=0)
plot(rb)
#Simulando AR1
ar1 = ts(ar.sim(500, rho = 0.7), start=0)
plot(ar1)
#Simulando MA2
#Vamos usar a função arima.sim, do pacote stats (carregando, por padrão, no R)
ma2 = ts(ma.sim( 500, psi = c(1,0.5) ),start = 0)
plot(ma2)
#Simulando ARMA(1,2)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
plot(arma12)
#Processo determinístico
det = 0.01*0:500 + rb
plot(ts(det,start=0))
#Passeio aleatorio
rw = ts(ar.sim(500, rho=1), start = 0)
plot(rw)
#Quebra de nível
break_mean = ts(c(ar.sim(250, rho=0),2+ar.sim(250,rho=0)), start = 0)
plot(break_mean)
#Quebra de variância
break_sd = ts(c(ar.sim(250, rho=0),2*ar.sim(250,rho=0)), start = 0)
plot(break_sd)
#Decompondo séries de tempo
#Fixando pasta com arquivos
setwd("~/Documentos/GitHub/Econometria-III/codigos/Decomposicoes/")
#Carregando pacotes necessários. Instale-os se não os possuir
library("seasonal") #Arima X13-Seats
library("mFilter") #Filtro HP
data = read.csv2("desemprego.csv")
desemprego_brasil = ts(data = data$Desemprego.PNADC., start = c(2012,03), frequency = 12)
plot(desemprego_brasil) #Série em nível
plot(diff(desemprego_brasil)) #Gráfico da primeira diferença: modelo aditivo parece razoável
#1. Ajuste de média móvel
decomposicao = decompose(desemprego_brasil, type = "additive")
desemprego_ajustado_cma = desemprego_brasil - decomposicao$seasonal
plot(desemprego_brasil)
lines(desemprego_ajustado_cma, col = 'blue')
#2. Ajuste via ARIMA X13-Seats
modelo_sazonal = seas(desemprego_brasil)
plot(modelo_sazonal)
desemprego_x13 = predict(modelo_sazonal)
#Filtro HP
filtrado = hpfilter(desemprego_x13,129600,type = "lambda")
plot(desemprego_x13, col='red')
lines(filtrado$trend,col='blue')
#Exemplificando viés de ponta com dados mais recentes
data = read.csv("desemprego_atualizado.csv")
desemp_atualizado = ts(data$Desemprego.PNADC., start = c(2012,03), frequency = 12)
desemp_x13 = predict(seas(desemp_atualizado))
desemp_menor = window(desemp_x13, end = c(2022,12))
filtrado_menor =  hpfilter(desemp_menor,129600,type = "lambda")$trend
filtrado_cheio =  hpfilter(desemp_x13,129600,type = "lambda")$trend
plot(desemp_x13)
lines(filtrado_menor, col = 'red')
lines(filtrado_cheio, col = 'blue')
legend('topleft', c('Tendência HP (estimação até dez/2022)', 'Tendência HP (estimação até jan/2024)'),
col = c('red','blue'),lty = c(1,1), cex = 0.7)
#Proposta de Hamilton
base = cbind(lag(desemp_x13,-4),do.call(cbind, lapply(0:3, function(x) lag(desemp_x13, x))))
colnames(base) = c('forward', paste('L',0:3,sep=''))
model = lm(forward~., data = base)
predict(model)
help(predict)
predict(model, na.action = na.exclude)
predict(model, na.action = na.pass)
base = cbind(desemp_x13,do.call(cbind, lapply(24+0:3, function(x) lag(desemp_x13, x))))
colnames(base) = c('desemp', paste('L',0:3,sep=''))
model = lm(desemp~., data = base)
View(base)
base = cbind(desemp_x13,do.call(cbind, lapply(24+0:3, function(x) lag(desemp_x13, x))))
View(base)
lag(desemp_x13,2)
base = cbind(desemp_x13,do.call(cbind, lapply(-24-0:3, function(x) lag(desemp_x13, x))))
View(base)
colnames(base) = c('desemp', paste('L',0:3,sep=''))
base
model = lm(desemp~., data = base)
model = lm(desemp~., data = base)
base = cbind(base, "trend_hamilton" = NA)
base
complete.cases(base[,1:4])
base[complete.cases(base[,1:4]),"trend_hamilton"] = predict(model)
model = lm(desemp~., data = base)
base = cbind(desemp_x13,do.call(cbind, lapply(-24-0:3, function(x) lag(desemp_x13, x))))
colnames(base) = c('desemp', paste('L',0:3,sep=''))
model = lm(desemp~., data = base)
base = cbind(base, "trend_hamilton" = NA)
base[complete.cases(base[,1:4]),"trend_hamilton"] = predict(model)
complete.cases(base[,1:4])
base[complete.cases(base[,2:4]),"trend_hamilton"] = predict(model)
complete.cases(base[,2:4])
base = cbind(base, "trend_hamilton" = NA)
base[complete.cases(base[,2:4]),"trend_hamilton"] = predict(model)
predict(model)
predict(model, na.action = na.omit())
predict(model, na.action = na.omit)
predict(model, na.action = na.ignore)
predict(model, na.action = na.pass)
predict(model, na.rm = F)
predict(model, na.rm = na.omit)
predict(model, na.action =  na.omit)
help("predict.lm")
predict(model, na.action=na.exclude)
model = lm(desemp~., data = base)
base = cbind(desemp_x13,do.call(cbind, lapply(-24-0:3, function(x) lag(desemp_x13, x))))
colnames(base) = c('desemp', paste('L',0:3,sep=''))
model = lm(desemp~., data = base)
base = cbind(base, "trend_hamilton" = NA)
predict(model, na.action=na.exclude)
predict(model, base, na.action=na.exclude)
base
base = cbind(desemp_x13,do.call(cbind, lapply(-24-0:3, function(x) lag(desemp_x13, x))))
colnames(base) = c('desemp', paste('L',0:3,sep=''))
model = lm(desemp~., data = base)
predict(model, base, na.action=na.exclude)
predict(model, base, na.action=na.pass)
predict(model, base)
base = cbind(base, 'hamilton' = predict(model, base))
View(base)
base
plot(base[,1])
lines(base[,"hamilton"], col = 'blue')
lines(base[,"hamilton"], col = 'blue')
model
#Proposta de Hamilton
base = cbind(desemp_x13,do.call(cbind, lapply(-24-0:3, function(x) lag(desemp_x13, x))))
colnames(base) = c('desemp', paste('L',0:3,sep=''))
model = lm(desemp~., data = base)
base = cbind(base, 'hamilton_cycle' =base[,1]- predict(model, base))
plot(base[,"hamilton_cycle"], col = 'blue')
plot(base[,"hamilton_cycle"], col = 'blue')
abline(h=0)
#Decompondo séries de tempo
#Fixando pasta com arquivos
setwd("~/Documentos/GitHub/Econometria-III/codigos/Decomposicoes/")
#Carregando pacotes necessários. Instale-os se não os possuir
library("seasonal") #Arima X13-Seats
library("mFilter") #Filtro HP
data = read.csv2("pib_tri.csv")
pib_brasil = ts(data = data$X22099...Quarterly.GDP...observed.data...GDP.at.market.prices...Index, start = c(1995,01), frequency = 4)
plot(pib_brasil) #Série em nível
plot(diff(pib_brasil))
#Gráfico da primeira diferença: modelo multiplicativo parece ok, variabilidade muda a partir de 2015
#Vale checar também com modelo aditivo.
add_model = ts(sin(2*pi*1:500/12) + 0.001*t + arima.sim(list(ar=0.7 ),n = 500),start= 0)
add_model = ts(sin(2*pi*1:500/12) + 0.001*1:500 + arima.sim(list(ar=0.7 ),n = 500),start= 0)
plot(add_model)
plot(diff(add_model))
plot(add_model)
add_model = ts(sin(2*pi*1:500/12) + 0.01*1:500 + arima.sim(list(ar=0.7 ),n = 500),start= 0)
plot(add_model)
plot(diff(add_model))
add_model = ts(sin(2*pi*1:500/12) + 0.01*1:500 + arima.sim(list(ar=0.7 ),n = 500),start= 0)
plot(add_model)
1/(1-0.7)^2
add_model = ts(10*sin(2*pi*1:500/12) + arima.sim(list(ar=0.7 ),n = 500),start= 0)
add_model = ts(10*sin(2*pi*1:500/12) + arima.sim(list(ar=0.7 ),n = 500),start= 0)
add_model = ts(10*sin(2*pi*1:500/12) + arima.sim(list(ar=0.7 ),n = 500),start= 0)
add_model = ts(10*sin(2*pi*1:500/12) + arima.sim(list(ar=0.7 ),n = 500),start= 0)
add_model = ts(10*sin(2*pi*1:500/12) + arima.sim(list(ar=0.7 ),n = 500),start= 0)
plot(add_model)
add_model = ts(sin(2*pi*1:500/12) + arima.sim(list(ar=0.7 ),n = 500),start= 0)
plot(add_model)
plot(diff(add_model))
plot(diff(add_model))
add_model = ts(sin(2*pi*1:500/12) + arima.sim(list(ar=1.0 ),n = 500),start= 0)
add_model = ts(sin(2*pi*1:500/12) + cumsum(c(0,rnorm(500))),n = 500),start= 0)
cumsum(c(0,rnorm(500)))
add_model = ts(sin(2*pi*1:500/12) + cumsum(c(0,rnorm(499))),n = 500),start= 0)
add_model = ts(sin(2*pi*1:500/12) + cumsum(rnorm(500)),start= 0)
plot(add_model)
plot(diff(add_model))
plot(add_model)
#Fixando semente para permitir a replicação
set.seed(123)
#Modelo aditivo da forma
#a*sin(2*pi*t/12)  + u_t, onde u_t é passeio aleatório
add_model = ts(sin(2*pi*1:500/12) + cumsum(rnorm(500)),start= 0)
plot(add_model)
plot(diff(add_model))
#Fixando semente para permitir a replicação
set.seed(123)
#Modelo aditivo da forma
#a*sin(2*pi*t/12)  + u_t, onde u_t é passeio aleatório
add_model = ts(sin(2*pi*1:500/12) + cumsum(rnorm(500)),start= 0)
plot(add_model)
plot(diff(add_model))
#Modelo multiplicativo da forma
#a*sin(2*pi*t/12)*u_t, onde u_t é passeio aleatório
mult_model = ts(sin(2*pi*1:500/12) + cumsum(rnorm(500)),start= 0)
plot(mult_model)
plot(diff(mult_model))
#Fixando semente para permitir a replicação
set.seed(123)
#Modelo aditivo da forma
#a*sin(2*pi*t/12)  + u_t, onde u_t é passeio aleatório
add_model = ts(sin(2*pi*1:500/12) + cumsum(rnorm(500)),start= 0)
plot(add_model)
plot(diff(add_model))
#Modelo multiplicativo da forma
#a*sin(2*pi*t/12)*u_t, onde u_t é passeio aleatório
mult_model = ts(sin(2*pi*1:500/12)*cumsum(rnorm(500)),start= 0)
plot(mult_model)
plot(diff(mult_model))
plot(mult_model)
(diff(mult_model))
plot(diff(mult_model))
#Fixando semente para permitir a replicação
set.seed(123)
#Modelo aditivo da forma
#a*sin(2*pi*t/12)  + u_t, onde u_t é passeio aleatório
add_model = ts(sin(2*pi*1:500/12) + cumsum(rnorm(500)),start= 0)
plot(add_model)
plot(diff(add_model))
#Modelo multiplicativo da forma
#a*sin(2*pi*t/12)*t*u_t, onde u_t é passeio aleatório
mult_model = ts(sin(2*pi*1:500/12)*1:500*cumsum(rnorm(500)),start= 0)
plot(mult_model)
plot(diff(mult_model))
plot(mult_model)
mult_model = ts(1:500*cumsum(rnorm(500)),start= 0)
plot(mult_model)
plot(diff(mult_model))
plot(mult_model)
#Modelo multiplicativo da forma
#a*t*u_t, onde u_t é passeio aleatório
mult_model = ts(1:500*cumsum(rnorm(500)),start= 0)
plot(mult_model)
plot(diff(mult_model))
