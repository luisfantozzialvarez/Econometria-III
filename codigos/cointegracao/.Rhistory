1405-1186
1405-1186-60
159/12
setwd("/Users/luisalvarez/Documents/GitHub/Econometria-III/codigos/cointegracao")
#Fixando ambiente
setwd("~/Documents/GitHub/Econometria-III/codigos/cointegracao")
library("CADFtest")
library("car")
library("lmtest")
library("sandwich")
library("vars")
#Pacote para testes de cointegração
library('urca')
library('vars')
help(VARSelect)
help(VARselect)
acf(diff(dados))
#Fixando ambiente
setwd("~/Documents/GitHub/Econometria-III/codigos/cointegracao")
library("CADFtest")
library("car")
library("lmtest")
library("sandwich")
library("vars")
#Pacote para testes de cointegração
library('urca')
library('vars')
ibc = read.csv2('ibc.csv')
ibc = ts(log(ibc[,2]), start=c(substring(ibc[1,1],1,4),substring(ibc[1,1],6,7)),frequency=12)
m1 = read.csv2('m1.csv')
m1 = ts(log(m1[,2]), start=c(substring(m1[1,1],1,4),substring(m1[1,1],6,7)),frequency=12)
igp = read.csv2('igp.csv')
igp = ts(log(igp[,2]), start=c(substring(igp[1,1],1,4),substring(igp[1,1],6,7)),frequency=12)
dados = cbind(ibc,m1,igp)
dados = window(dados, start = c(2003,1), end = c(2024,2))
#Ao rodar o procedimento sequencial, notamos que todas as séries são I(1),
#e que m1 e igp exibem drift (intercepto na primeira diferença)
acf(diff(dados))
#Selecionando coeficientes com base no VAR em nível. Note que, como há drift,
#devemos incluir uma tendência linear em nível
criterios = VARselect(dados, lag.max = 20, type = 'both', season=12)
criterios
help("VARselect")
modelo_nivel = VAR(dados, type = 'both', p=13, season=12)
summary(modelo_nivel)
serial.test(modelo_nivel, type = c('PT.adjusted'))
serial.test(modelo_nivel, type = c('PT'))
serial.test(modelo_nivel, type = c('BG'))
serial.test(modelo_nivel, type = c('PT.asymptotic'))
serial.test(modelo_nivel, type = c('PT.adjusted'), lag.max=16)
help(serial.test)
serial.test(modelo_nivel, type = c('PT.adjusted'), lags.pt=16)
serial.test(modelo_nivel, type = c('BG'), lags.bg=2)
serial.test(modelo_nivel, type = c('BG'), lags.bg=2)
serial.test(modelo_nivel, type = c('BG'), lags.bg=3)
serial.test(modelo_nivel, type = c('BG'), lags.bg=3)
serial.test(modelo_nivel, type = c('BG'), lags.bg=3)
LM = 2*(logLik(modelo_nivel)- VAR(dados, type = 'both', p=12, season=12))
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=12, season=12)))
LM
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel, type = c('BG'), lags.bg=3)
modelo_nivel = VAR(dados, type = 'both', p=14, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=13, season=12)))
print(LM>qchisq(0.95,9))
LM
logLik(modelo_nivel)
serial.test(modelo_nivel, type = c('BG'), lags.bg=3)
serial.test(modelo_nivel)
modelo_nivel = VAR(dados, type = 'both', p=13, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=13, season=12)))
print(LM>qchisq(0.95,9))
modelo_nivel = VAR(dados, type = 'both', p=13, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=12, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel, type = c('BG'))
serial.test(modelo_nivel, type = c('BG'))
serial.test(modelo_nivel, type = c('BG'), lags.bg = 3)
help("ca.jo")
johansen = ca.jo(dados, type = 'eigen', ecdet = c('none'), K=13,spec = 'transitory', season=12)
summary(johansen)
criterios = VARselect(dados, lag.max = 20, type = 'both', season=12)
criterios
modelo_nivel = VAR(dados, type = 'both', p=2, season=12)
modelo_nivel = VAR(dados, type = 'both', p=2, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=1, season=12)))
print(LM>qchisq(0.95,9))
LM
serial.test(modelo_nivel, type = c('BG'), lags.bg = 3)
serial.test(modelo_nivel)
help(VAR)
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=2, season=12)))
print(LM>qchisq(0.95,9))
LM
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=2, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
modelo_nivel = VAR(dados, type = 'both', p=2, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=1, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=2, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
modelo_nivel = VAR(dados, type = 'both', p=4, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=3, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
LM
serial.test(modelo_nivel)
modelo_nivel = VAR(dados, type = 'both', p=4, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=3, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
modelo_nivel = VAR(dados, type = 'both', p=5, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=4, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
modelo_nivel = VAR(dados, type = 'both', p=6, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=4, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
modelo_nivel = VAR(dados, type = 'both', p=6, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=5, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
LM
modelo_nivel = VAR(dados, type = 'both', p=7, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=6, season=12)))
LM
logLik(VAR(dados, type = 'both', p=6, season=12)
)
help("logLik.vars")
modelo_nivel = VAR(dados, type = 'both', p=10, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=9, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
LM
ogLik(VAR(dados, type = 'both', p=9, season=12)
help("logLik")
modelo_nivel = VAR(dados, type = 'both', p=2, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=1, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel)
serial.test(modelo_nivel, type = 'BG')
#Aumentando
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=2, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel, type = 'BG')
#Aumentando
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=2, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel, type = 'BG')
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=2, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel, type = 'BG', lags.bg =5)
help(serial.test)
#Selecionando com base no BIC
modelo_nivel = VAR(dados, type = 'both', p=2, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=1, season=12)))
print(LM>qchisq(0.95,9))
#Vamos olhar o teste de Breusch-Godfrey de não correlação serial
serial.test(modelo_nivel, type = 'BG', lags.bg =5)
#Aumentando
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=2, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel, type = 'BG', lags.bg =5)
johansen = ca.jo(dados, type = 'eigen', ecdet = c('none'), K=3,spec = 'transitory', season=12)
summary(johansen)
bhl6
matrix(c(0,1,0), c(0,0,1), dim=2)
matrix(c(0,1,0), c(0,0,1), nrow=3)
matrix(c(c(0,1,0), c(0,0,1)), nrow=3)
teste = bh6lrtest(johansen, matrix(c(c(0,1,0), c(0,0,1)), nrow=3), r=1, r1=1)
summary(teste)
summary(johansen)
teste = blrtest(johansen, matrix(c(c(0,1,0), c(0,0,1)), nrow=3), r=1)
summary(teste)
teste = bh5lrtest(johansen, matrix(c(1,-1,1), nrow=3), r=1)
matrix(c(1,-1,1), nrow=3),
matrix(c(1,-1,1), nrow=3)
bh5lrtest(johansen, matrix(c(1,-1,1), nrow=3), r=1)
modelo = cajorls(johansen, r=1)
summary(modelo)
summary(modelo$rlm)
modelo$beta
teste = blrtest(johansen, matrix(c(c(0,1,0), c(0,0,1)), nrow=3), r=1)
#Claramente rejeitamos a nula
summary(teste)
modelo = cajorls(johansen, r=1)
modelo$beta
summary(modelo$rlm)
help(vec2var)
vs = vec2var(johansen, r=1)
forecast(vs)
predict(vs)
fanchart(predict(vs))
help(fanchart)
fanchart(predict(vs), plot.type = 'single')
cajorls(johansen, r=1)
modelo$beta
summary(modelo$rlm)
modelo = cajools(johansen)
summary(modelo)
modelo = cajorls(johansen, r=1)
modelo$beta
summary(modelo$rlm)
#Fixando ambiente
setwd("~/Documents/GitHub/Econometria-III/codigos/cointegracao")
library("CADFtest")
library("car")
library("lmtest")
library("sandwich")
library("vars")
#Pacote para testes de cointegração
library('urca')
library('vars')
ibc = read.csv2('ibc.csv')
ibc = ts(log(ibc[,2]), start=c(substring(ibc[1,1],1,4),substring(ibc[1,1],6,7)),frequency=12)
m1 = read.csv2('m1.csv')
m1 = ts(log(m1[,2]), start=c(substring(m1[1,1],1,4),substring(m1[1,1],6,7)),frequency=12)
igp = read.csv2('igp.csv')
igp = ts(log(igp[,2]), start=c(substring(igp[1,1],1,4),substring(igp[1,1],6,7)),frequency=12)
dados = cbind(ibc,m1,igp)
dados = window(dados, start = c(2003,1), end = c(2024,2))
#Ao rodar o procedimento sequencial, notamos que todas as séries são I(1),
#e que m1 e igp exibem drift (intercepto na primeira diferença)
#Evidência de sazonalidade
acf(diff(dados))
#Selecionando coeficientes com base no VAR em nível. Note que, como há drift,
#devemos incluir uma tendência linear em nível
criterios = VARselect(dados, lag.max = 20, type = 'both', season=12)
#Selecionando com base no BIC
modelo_nivel = VAR(dados, type = 'both', p=2, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=1, season=12)))
print(LM>qchisq(0.95,9))
#Vamos olhar o teste de Breusch-Godfrey de não correlação serial
serial.test(modelo_nivel, type = 'BG', lags.bg =5)
#Aumentando
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=2, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel, type = 'BG', lags.bg =5)
#p=3 parece ok
#Vamos trabalhar com 3 defasagens
johansen = ca.jo(dados, type = 'eigen', ecdet = c('none'), K=3,spec = 'transitory', season=12)
summary(johansen)
#Conclusão do teste: UMA relação de cointegração
#Testando a nula de que atividade econômica NÃ0 participa da relação de cointegração
teste = blrtest(johansen, matrix(c(c(0,1,0), c(0,0,1)), nrow=3), r=1)
summary(teste)
#Claramente rejeitamos a nula
modelo = cajorls(johansen, r=1)
modelo$rlm
sa = modelo$rlm
logLik(sa)
modelo = cajorls(johansen, r=1)
modelo$beta
summary(modelo$rlm)
#Representação em VAR
vs = vec2var(johansen, r=1)
logLik(vs)
help("bh5lrtest")
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), nrow=3), r=1)
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=1)
matrix(c(1, -1,1))
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=2)
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=1)
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=1)
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=1)
help(blrtest)
help(stability)
help("bh5lrtest")
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=1)
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=1)
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=1)
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=1)
teste = bh5lrtest(johansen, matrix(c(1, -1,1)), r=2)
summary(teste)
teste = bh5lrtest(johansen, matrix(c(1, -1,0)), r=2)
summary(teste)
teste = blrtest(johansen, matrix(c(c(0,1,0), c(0,0,1)), nrow=3), r=1)
summary(teste)
teste = blrtest(johansen, matrix(c(1,-1,1),nrow=1), r=1)
teste = blrtest(johansen, matrix(c(1,-1,1),nrow=3), r=1)
summary(teste)
teste = blrtest(johansen, matrix(c(c(0,1,0), c(0,0,1)), nrow=3), r=1)
summary(teste)
teste = blrtest(johansen, matrix(c(1,-1,1),nrow=3), r=1)
summary(teste)
modelo$beta
teste = blrtest(johansen, matrix(c(1,-0.5,0.46),nrow=3), r=1)
summary(teste)
teste = blrtest(johansen, matrix(c(1,-1,1),nrow=3), r=1)
summary(teste)
#Testando a nula de que equação quantitativa é boa descrição
teste = blrtest(johansen, matrix(c(1,-1,1),nrow=3), r=1)
summary(teste)
#Também rejeitamos a nula!
modelo = cajorls(johansen, r=1)
modelo$beta
summary(modelo$rlm)
dados
#Fixando ambiente
setwd("~/Documents/GitHub/Econometria-III/codigos/cointegracao")
library("CADFtest")
library("car")
library("lmtest")
library("sandwich")
library("vars")
#Pacote para testes de cointegração
library('urca')
ibc = read.csv2('ibc.csv')
ibc = ts(log(ibc[,2]), start=c(substring(ibc[1,1],1,4),substring(ibc[1,1],6,7)),frequency=12)
m1 = read.csv2('m1.csv')
m1 = ts(log(m1[,2]), start=c(substring(m1[1,1],1,4),substring(m1[1,1],6,7)),frequency=12)
igp = read.csv2('igp.csv')
igp = ts(log(igp[,2]), start=c(substring(igp[1,1],1,4),substring(igp[1,1],6,7)),frequency=12)
dados = cbind(ibc,m1,igp)
dados = window(dados, start = c(2003,1), end = c(2024,2))
#Ao rodar o procedimento sequencial, notamos que todas as séries são I(1),
#e que m1 e igp exibem drift (intercepto na primeira diferença)
###############################
#Procedimento de Engle Granger#
###############################
#Vamos testar se há uma relação de longo prazo entre as variáveis
#Vamos considerar o caso em que igp deve participar da relação (caso ela exista),
#visto o que esperamos da neutralidade do longo prazo e da teoria quantitativa
teste = lm(igp~m1+ibc, data=dados)
res= ts(residuals(teste),start = c(2003,1),frequency=12)
ur.pp(res, type = c("Z-tau"))
#Olhando a tabela dos slides, valor crítico para n=3, com drift do lado direito (Caso 3)
#a 1% é: -4.36. Logo, como -4.66 < -4.36, rejeitamos a nula -> há cointegração.
#Para os testes de hipótese, sabemos que é curcial que (Delta m1 e Delta ibc) não sejam
#correlacionados, contemporanea ou extemporaneamente, com o erro da relação de longo prazo
#Vamos checar isso
est = cbind(diff(dados[,c("ibc","m1")]), res)
colnames(est) = c('d_ibc','d_m1', 'err')
est= est[-1,]
acf(est)
#Alguma evidência pontual de correlação, o que sugere que devemos tomar cuidado com a
#inferência no vetor de cointegração.
#Intervalos de confiança para os coeficientes da equaçào
coefci(teste, vcov. = vcovHAC)
#Intervalos compatíveis com a equação quantitativa
modelo$beta
#Testando a nula de que equação quantitativa é boa descrição
teste = blrtest(johansen, matrix(c(1,-1,1),nrow=3), r=1)
summary(teste)
modelo = cajorls(johansen, r=1)
modelo$beta
#Representação em VAR
vs = vec2var(johansen, r=1)
fanchart(predict(vs), plot.type = 'single')
library("CADFtest")
library("car")
library("lmtest")
library("sandwich")
library("vars")
#Pacote para testes de cointegração
library('urca')
library('vars')
ibc = read.csv2('ibc.csv')
ibc = ts(log(ibc[,2]), start=c(substring(ibc[1,1],1,4),substring(ibc[1,1],6,7)),frequency=12)
m1 = read.csv2('m1.csv')
m1 = ts(log(m1[,2]), start=c(substring(m1[1,1],1,4),substring(m1[1,1],6,7)),frequency=12)
igp = read.csv2('igp.csv')
igp = ts(log(igp[,2]), start=c(substring(igp[1,1],1,4),substring(igp[1,1],6,7)),frequency=12)
dados = cbind(ibc,m1,igp)
dados = window(dados, start = c(2003,1), end = c(2024,2))
#Ao rodar o procedimento sequencial, notamos que todas as séries são I(1),
#e que m1 e igp exibem drift (intercepto na primeira diferença)
#Evidência de sazonalidade
acf(diff(dados))
#Selecionando coeficientes com base no VAR em nível. Note que, como há drift,
#devemos incluir uma tendência linear em nível
criterios = VARselect(dados, lag.max = 20, type = 'both', season=12)
#Selecionando com base no BIC
modelo_nivel = VAR(dados, type = 'both', p=2, season=12)
summary(modelo_nivel)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=1, season=12)))
print(LM>qchisq(0.95,9))
#Vamos olhar o teste de Breusch-Godfrey de não correlação serial
serial.test(modelo_nivel, type = 'BG', lags.bg =5)
#Aumentando
modelo_nivel = VAR(dados, type = 'both', p=3, season=12)
LM = 2*(logLik(modelo_nivel)- logLik(VAR(dados, type = 'both', p=2, season=12)))
print(LM>qchisq(0.95,9))
serial.test(modelo_nivel, type = 'BG', lags.bg =5)
#p=3 parece ok
#Vamos trabalhar com 3 defasagens
johansen = ca.jo(dados, type = 'eigen', ecdet = c('none'), K=3,spec = 'transitory', season=12)
summary(johansen)
#Conclusão do teste: UMA relação de cointegração
#Testando a nula de que atividade econômica NÃ0 participa da relação de cointegração
teste = blrtest(johansen, matrix(c(c(0,1,0), c(0,0,1)), nrow=3), r=1)
summary(teste)
#Claramente rejeitamos a nula
#Testando a nula de que equação quantitativa é boa descrição
teste = blrtest(johansen, matrix(c(1,-1,1),nrow=3), r=1)
summary(teste)
#Também rejeitamos a nula!
modelo = cajorls(johansen, r=1)
modelo$beta
summary(modelo$rlm)
#Representação em VAR
vs = vec2var(johansen, r=1)
#Preidções
fanchart(predict(vs), plot.type = 'single')
