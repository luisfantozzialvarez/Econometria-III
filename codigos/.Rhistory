{
noise = rnorm(Nperiods+length(psi), sd = sigma)
vec_lg = sapply(0:length(psi), function(x){
noise[(length(psi)-x+1):(length(noise)-x)]
})
mov = as.numeric(vec_lg%*%c(1,psi))
}
#Fixa semente do simulador - para replicar resultados
set.seed(13579)
#Simulando ruído branco
rb = ts(ar.sim(500, rho = 0), start=0)
plot(rb)
#Simulando AR1
ar1 = ts(ar.sim(500, rho = 0.7), start=0)
plot(ar1)
#Simulando MA2
#Vamos usar a função arima.sim, do pacote stats (carregando, por padrão, no R)
ma2 = ts(ma.sim( 500, psi = c(1,0.5) ),start = 0)
plot(ma2)
#Simulando ARMA(1,2)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
plot(arma12)
#Processo determinístico
det = 0.01*0:500 + rb
plot(ts(det,start=0))
#Passeio aleatorio
rw = ts(ar.sim(500, rho=1), start = 0)
plot(rw)
#Quebra de média
break_mean = ts(c(ar.sim(250, rho=0),2+ar.sim(250,rho=0)), start = 0)
plot(break_mean)
#Função para simular um processo da forma
#Y_t = alpha + rho*y_{t-1} + epsilon_t
#onde epsilon_t ~ N(0, sigma^2) iid
#Se |rho| < 1, processo é inicializado como y_0 ~ N(alpha/(1-rho), sigma^2/(1-rho^2))
#do contrário, processo inicia em alpha.
ar.sim <- function(Nperiods, rho, alpha = 0, sigma = 1)
{
if(abs(rho)<1)
y = rnorm(1, alpha/(1-rho), sd = sigma/sqrt(1-rho^2)) else y = alpha
epsilon = rnorm(Nperiods, mean = 0, sd = sigma)
for(j in 1:Nperiods)
y = c(y, alpha + rho*y[j] + epsilon[j])
return(y)
}
#Função para simular um MA(q) Gaussiano. O comprimento do vetor q determina a ordem do MA
ma.sim <- function(Nperiods, psi = c(), alpha = 0, sigma = 1)
{
noise = rnorm(Nperiods+length(psi), sd = sigma)
vec_lg = sapply(0:length(psi), function(x){
noise[(length(psi)-x+1):(length(noise)-x)]
})
mov = as.numeric(vec_lg%*%c(1,psi))
}
#Fixa semente do simulador - para replicar resultados
set.seed(13579)
#Simulando ruído branco
rb = ts(ar.sim(500, rho = 0), start=0)
plot(rb)
#Simulando AR1
ar1 = ts(ar.sim(500, rho = 0.7), start=0)
plot(ar1)
#Simulando MA2
#Vamos usar a função arima.sim, do pacote stats (carregando, por padrão, no R)
ma2 = ts(ma.sim( 500, psi = c(1,0.5) ),start = 0)
plot(ma2)
#Simulando ARMA(1,2)
arma12 = ts(arima.sim(list(ar=0.7, ma =c(1,0.5) ),n = 500),start= 0)
plot(arma12)
#Processo determinístico
det = 0.01*0:500 + rb
plot(ts(det,start=0))
#Passeio aleatorio
rw = ts(ar.sim(500, rho=1), start = 0)
plot(rw)
#Quebra de nível
break_mean = ts(c(ar.sim(250, rho=0),2+ar.sim(250,rho=0)), start = 0)
plot(break_mean)
#Quebra de variância
break_sd = ts(c(ar.sim(250, rho=0),2*ar.sim(250,rho=0)), start = 0)
plot(break_sd)
#Fixando semente para permitir a replicação
set.seed(123)
#Modelo aditivo da forma
#a*sin(2*pi*t/12)  + u_t, onde u_t é passeio aleatório
add_model = ts(sin(2*pi*1:500/12) + cumsum(rnorm(500)),start= 0)
plot(add_model)
plot(diff(add_model))
#Modelo multiplicativo da forma
#a*t*u_t, onde u_t é passeio aleatório
mult_model = ts(1:500*cumsum(rnorm(500)),start= 0)
plot(mult_model)
plot(diff(mult_model))
#Fixando semente para permitir a replicação
set.seed(123)
#Modelo aditivo da forma
#a*sin(2*pi*t/12)  + u_t, onde u_t é passeio aleatório
add_model = ts(sin(2*pi*1:500/12) + cumsum(rnorm(500)),start= 0)
plot(add_model)
plot(diff(add_model))
mult_model = ts(1:500*cumsum(rnorm(500)),start= 0)
plot(mult_model)
plot(diff(mult_model))
#Decompondo séries de tempo
#Fixando pasta com arquivos
setwd("~/Documents/GitHub/Econometria-III/codigos/")
#Decompondo séries de tempo
#Fixando pasta com arquivos
setwd("~/Documentos/GitHub/Econometria-III/codigos/")
#Carregando pacotes necessários. Instale-os se não os possuir
library(forecast) #Pacote forecast para métodos de previsão
library(sandwich) #Erros padrão HAC
library(lmtest) #Testes com erros padrão robustos
#Carregando dados
data = read.csv2("Raiz_Unitaria/divida_liquida.csv")
divida = ts(data = data$Divida.liquida.do.Setor.publico, start = c(2001,12), frequency = 12)
plot(divida)
#Da aula anterior, sabemos que a série apresenta raiz unitária, e de:
trend = 1:(length(divida)-1)
regg = lm(diff(divida)~trend)
coeftest(regg, vcov. = vcovHAC)
#Série não apresenta componentes determinísticos na primeira diferença.
#Dessa forma, estimaremos o ARMA em primeiras diferenças (ARIMA(p,1,q)) sem intercepto ou tendência.
#FAC e FACP do processo estacionarizado (no nosso caso, basta tirar as diferenças,
#pois n há não estacionariedade determinística uma vez que o processo é diferenciado)
acf(diff(divida), lag.max = 40)
pacf(diff(divida), lag.max = 40)
#Da inspeção visual da FAC e FACP, o processo parece ser compatível com MA(2)
#No entanto, FACP, apesar de aparentemente exibir decaimento, poderia ser compatível com um componente
#AR(12)
#Vamos ser conservadores e considerar pmax = 12 e qmax = 2, e calcular todos os modelos:
pmax = 12
qmax = 2
#Vamos usar uma função auxiliar, que incluí no arquivo box_jenkins_parallel.R
source("Box_jenkins/box_jenkins_parallel.R")
tabela = arima.est.parallel(divida, pmax, qmax, d=1, include.constant = F, include.trend = F,
signif = 0.1, lags.lbox = c(20,30))
#Removendo modelos que não convergiram
tabela = tabela[tabela$Converged,]
#MA(2) e ARMA(5,2) parecem razoáveis. Vamos estimá-lo:
modelo = Arima(divida, order =c(0,1,2), include.constant = F, include.drift = F)
summary(modelo)
checkresiduals(modelo)
forecast(modelo)
plot(forecast(modelo))
# ARMA(5,2)
modelo2 = Arima(divida, order =c(5,1,2), include.constant = F, include.drift = F)
summary(modelo2)
checkresiduals(modelo2)
forecast(modelo2)
plot(forecast(modelo2))
#Resultados parecidos: vamos ficar com o modelo mais parcimonioso
#Vamos usar o modelo para calcular a decomposição de beveridge Nelson
#Vamos fazer a decomposição a partir de Jan/2003
lp =c()
for(year in 2003:2023)
for(month in 1:12)
{
valor = forecast(Arima(window(divida,end=c(year,month)), model = modelo), h=1000)
lp = c(lp,valor$mean[1000])
}
lp = ts(lp, start = c(2003,1),frequency=12)
cycle_bn = divida - lp
plot(cycle_bn)
divida
lp =c()
for(year in 2001:2023)
for(month in 1:12)
{
if((year==2001)&(month!=12))
next
valor = forecast(Arima(window(divida,end=c(year,month)), model = modelo), h=1000)
lp = c(lp,valor$mean[1000])
}
lp =c()
for(year in 2004:2023)
for(month in 1:12)
{
valor = forecast(Arima(window(divida,end=c(year,month)), model = modelo), h=1000)
lp = c(lp,valor$mean[1000])
}
lp = ts(lp, start = c(2003,1),frequency=12)
cycle_bn = divida - lp
plot(cycle_bn)
lp =c()
for(year in 2003:2023)
for(month in 1:12)
{
valor = forecast(Arima(window(divida,end=c(year,month)), model = modelo), h=1000)
lp = c(lp,valor$mean[1000])
}
lp = ts(lp, start = c(2003,1),frequency=12)
cycle_bn = divida - lp
plot(cycle_bn)
divida
lp
plot(window(cycle_bn,start=c(2004,01))
)
warnings()
lp
lp =c()
for(year in 2004:2023)
for(month in 1:12)
{
valor = forecast(Arima(window(divida,end=c(year,month)), model = modelo), h=1000)
lp = c(lp,valor$mean[1000])
}
lp = ts(lp, start = c(2004,1),frequency=12)
cycle_bn = divida - lp
plot(cycle_bn)
acf(divida)
acf(diff(divida))
acf(diff(divida),lag.max=48)
#Decompondo séries de tempo
#Fixando pasta com arquivos
setwd("~/Documentos/GitHub/Econometria-III/codigos/")
#Carregando pacotes necessários. Instale-os se não os possuir
library(forecast) #Pacote forecast para métodos de previsão
library(sandwich) #Erros padrão HAC
library(lmtest) #Testes com erros padrão robustos
#Carregando dados
data = read.csv2("Raiz_Unitaria/divida_liquida.csv")
divida = ts(data = data$Divida.liquida.do.Setor.publico, start = c(2001,12), frequency = 12)
plot(divida)
#Da aula anterior, sabemos que a série apresenta raiz unitária, e de:
trend = 1:(length(divida)-1)
regg = lm(diff(divida)~trend)
coeftest(regg, vcov. = vcovHAC)
#Série não apresenta componentes determinísticos na primeira diferença.
#Dessa forma, estimaremos o ARMA em primeiras diferenças (ARIMA(p,1,q)) sem intercepto ou tendência.
#FAC e FACP do processo estacionarizado (no nosso caso, basta tirar as diferenças,
#pois n há não estacionariedade determinística uma vez que o processo é diferenciado)
acf(diff(divida), lag.max = 40)
pacf(diff(divida), lag.max = 40)
#Da inspeção visual da FAC e FACP, o processo parece ser compatível com MA(2)
#No entanto, FACP, apesar de aparentemente exibir decaimento, poderia ser compatível com um componente
#AR(12)
#Vamos ser conservadores e considerar pmax = 12 e qmax = 2, e calcular todos os modelos:
pmax = 12
qmax = 2
#Vamos usar uma função auxiliar, que incluí no arquivo box_jenkins_parallel.R
source("Box_jenkins/box_jenkins_parallel.R")
tabela = arima.est.parallel(divida, pmax, qmax, d=1, include.constant = F, include.trend = F,
signif = 0.1, lags.lbox = c(20,30))
#Removendo modelos que não convergiram
tabela = tabela[tabela$Converged,]
#MA(2) e ARMA(5,2) parecem razoáveis. Vamos estimá-lo:
modelo = Arima(divida, order =c(0,1,2), include.constant = F, include.drift = F)
summary(modelo)
checkresiduals(modelo)
forecast(modelo)
plot(forecast(modelo))
# ARMA(5,2)
modelo2 = Arima(divida, order =c(5,1,2), include.constant = F, include.drift = F)
summary(modelo2)
checkresiduals(modelo2)
forecast(modelo2)
plot(forecast(modelo2))
#Resultados parecidos: vamos ficar com o modelo mais parcimonioso
#Vamos usar o modelo para calcular a decomposição de beveridge Nelson
#Vamos fazer a decomposição a partir de Jan/2003
lp =c()
for(year in 2004:2023)
for(month in 1:12)
{
valor = forecast(Arima(window(divida,end=c(year,month)), model = modelo), h=1000)
lp = c(lp,valor$mean[1000])
}
lp = ts(lp, start = c(2004,1),frequency=12)
cycle_bn = divida - lp
divida
rm(list=ls())
#Decompondo séries de tempo
#Fixando pasta com arquivos
setwd("~/Documentos/GitHub/Econometria-III/codigos/")
#Carregando pacotes necessários. Instale-os se não os possuir
library(forecast) #Pacote forecast para métodos de previsão
library(sandwich) #Erros padrão HAC
library(lmtest) #Testes com erros padrão robustos
#Carregando dados
data = read.csv2("Raiz_Unitaria/divida_liquida.csv")
divida = ts(data = data$Divida.liquida.do.Setor.publico, start = c(2001,12), frequency = 12)
plot(divida)
#Da aula anterior, sabemos que a série apresenta raiz unitária, e de:
trend = 1:(length(divida)-1)
regg = lm(diff(divida)~trend)
coeftest(regg, vcov. = vcovHAC)
#Série não apresenta componentes determinísticos na primeira diferença.
#Dessa forma, estimaremos o ARMA em primeiras diferenças (ARIMA(p,1,q)) sem intercepto ou tendência.
#FAC e FACP do processo estacionarizado (no nosso caso, basta tirar as diferenças,
#pois n há não estacionariedade determinística uma vez que o processo é diferenciado)
acf(diff(divida), lag.max = 40)
pacf(diff(divida), lag.max = 40)
#Da inspeção visual da FAC e FACP, o processo parece ser compatível com MA(2)
#No entanto, FACP, apesar de aparentemente exibir decaimento, poderia ser compatível com um componente
#AR(12)
#Vamos ser conservadores e considerar pmax = 12 e qmax = 2, e calcular todos os modelos:
pmax = 12
qmax = 2
#Vamos usar uma função auxiliar, que incluí no arquivo box_jenkins_parallel.R
source("Box_jenkins/box_jenkins_parallel.R")
tabela = arima.est.parallel(divida, pmax, qmax, d=1, include.constant = F, include.trend = F,
signif = 0.1, lags.lbox = c(20,30))
#Removendo modelos que não convergiram
tabela = tabela[tabela$Converged,]
#MA(2) e ARMA(5,2) parecem razoáveis. Vamos estimá-lo:
modelo = Arima(divida, order =c(0,1,2), include.constant = F, include.drift = F)
summary(modelo)
checkresiduals(modelo)
forecast(modelo)
plot(forecast(modelo))
# ARMA(5,2)
modelo2 = Arima(divida, order =c(5,1,2), include.constant = F, include.drift = F)
summary(modelo2)
checkresiduals(modelo2)
forecast(modelo2)
plot(forecast(modelo2))
#Resultados parecidos: vamos ficar com o modelo mais parcimonioso
#Vamos usar o modelo para calcular a decomposição de beveridge Nelson
#Vamos fazer a decomposição a partir de Jan/2003
lp =c()
for(year in 2004:2023)
for(month in 1:12)
{
valor = forecast(Arima(window(divida,end=c(year,month)), model = modelo), h=1000)
lp = c(lp,valor$mean[1000])
}
lp = ts(lp, start = c(2004,1),frequency=12)
cycle_bn = divida - lp
plot(cycle_bn, main = 'Beveridge-Nelson')
plot(cycle_bn, main = 'Beveridge-Nelson')
abline(h=0, lty = 3)
modelo_sazonal = seas(divida)
#Decompondo séries de tempo
#Fixando pasta com arquivos
setwd("~/Documentos/GitHub/Econometria-III/codigos/")
#Carregando pacotes necessários. Instale-os se não os possuir
library(forecast) #Pacote forecast para métodos de previsão
library(sandwich) #Erros padrão HAC
library(lmtest) #Testes com erros padrão robustos
#Carregando pacotes necessários. Instale-os se não os possuir
library("seasonal") #Arima X13-Seats
library("mFilter") #Filtro HP
modelo_sazonal = seas(divida)
predict(modelo)
plot(modelo)
modelo_sazonal = seas(divida)
plot(modelo)
cycle_hp =   mFilter::hpfilter(divida,129600,type = "lambda")$cycle
cycle_hp
plot(cycle_hp)
base = cbind(divida,do.call(cbind, lapply(-24-0:3, function(x) lag(divida, x))))
colnames(base) = c('desemp', paste('L',0:3,sep=''))
model = lm(desemp~., data = base)
base = cbind(base, 'hamilton_cycle' =base[,1]- predict(model, base))
plot(base[,"hamilton_cycle"], col = 'blue')
abline(h=0)
plot(base[,"hamilton_cycle"], ylab='cycle_hamilton', main = 'Hamitlon')
abline(h=0,lty =3)
plot(cycle_hp, main = 'Filtro HP')
abline(h=0, lty = 3)
divida
cycle_hp =   mFilter::hpfilter(divida,129600,type = "lambda")$cycle
plot(window(cycle_hpm,start =c(2004,01)), main = 'Filtro HP')
base[,"hamilton_cycle"]
#Decompondo séries de tempo
#Fixando pasta com arquivos
setwd("~/Documentos/GitHub/Econometria-III/codigos/")
#Carregando pacotes necessários. Instale-os se não os possuir
library(forecast) #Pacote forecast para métodos de previsão
library(sandwich) #Erros padrão HAC
library(lmtest) #Testes com erros padrão robustos
#Carregando dados
data = read.csv2("Raiz_Unitaria/divida_liquida.csv")
divida = ts(data = data$Divida.liquida.do.Setor.publico, start = c(2001,12), frequency = 12)
plot(divida)
#Da aula anterior, sabemos que a série apresenta raiz unitária, e de:
trend = 1:(length(divida)-1)
regg = lm(diff(divida)~trend)
coeftest(regg, vcov. = vcovHAC)
#Série não apresenta componentes determinísticos na primeira diferença.
#Dessa forma, estimaremos o ARMA em primeiras diferenças (ARIMA(p,1,q)) sem intercepto ou tendência.
#FAC e FACP do processo estacionarizado (no nosso caso, basta tirar as diferenças,
#pois n há não estacionariedade determinística uma vez que o processo é diferenciado)
acf(diff(divida), lag.max = 40)
pacf(diff(divida), lag.max = 40)
#Da inspeção visual da FAC e FACP, o processo parece ser compatível com MA(2)
#No entanto, FACP, apesar de aparentemente exibir decaimento, poderia ser compatível com um componente
#AR(12)
#Vamos ser conservadores e considerar pmax = 12 e qmax = 2, e calcular todos os modelos:
pmax = 12
qmax = 2
#Vamos usar uma função auxiliar, que incluí no arquivo box_jenkins_parallel.R
source("Box_jenkins/box_jenkins_parallel.R")
tabela = arima.est.parallel(divida, pmax, qmax, d=1, include.constant = F, include.trend = F,
signif = 0.1, lags.lbox = c(20,30))
#Removendo modelos que não convergiram
tabela = tabela[tabela$Converged,]
#MA(2) e ARMA(5,2) parecem razoáveis. Vamos estimá-lo:
modelo = Arima(divida, order =c(0,1,2), include.constant = F, include.drift = F)
summary(modelo)
checkresiduals(modelo)
forecast(modelo)
plot(forecast(modelo))
# ARMA(5,2)
modelo2 = Arima(divida, order =c(5,1,2), include.constant = F, include.drift = F)
summary(modelo2)
checkresiduals(modelo2)
forecast(modelo2)
plot(forecast(modelo2))
#Resultados parecidos: vamos ficar com o modelo mais parcimonioso
#Vamos usar o modelo para calcular a decomposição de beveridge Nelson
#Vamos fazer a decomposição a partir de Jan/2003
lp =c()
for(year in 2004:2023)
for(month in 1:12)
{
valor = forecast(Arima(window(divida,end=c(year,month)), model = modelo), h=1000)
lp = c(lp,valor$mean[1000])
}
lp = ts(lp, start = c(2004,1),frequency=12)
cycle_bn = divida - lp
plot(cycle_bn, main = 'Beveridge-Nelson')
abline(h=0, lty = 3)
cycle_hp =   mFilter::hpfilter(divida,129600,type = "lambda")$cycle
plot(window(cycle_hpm,start =c(2004,01)), main = 'Filtro HP')
cycle_hp =   mFilter::hpfilter(divida,129600,type = "lambda")$cycle
plot(window(cycle_hp,start =c(2004,01)), main = 'Filtro HP')
abline(h=0, lty = 3)
base = cbind(divida,do.call(cbind, lapply(-24-0:3, function(x) lag(divida, x))))
colnames(base) = c('desemp', paste('L',0:3,sep=''))
model = lm(desemp~., data = base)
base = cbind(base, 'hamilton_cycle' =base[,1]- predict(model, base))
plot(window(base[,"hamilton_cycle"],start=c(2004,01),end=c(2021,12)), ylab='cycle_hamilton', main = 'Hamitlon')
abline(h=0,lty =3)
cycle_hp =   mFilter::hpfilter(divida,129600,type = "lambda")$cycle
plot(window(cycle_hp,start =c(2004,01)), main = 'Filtro HP', xlab='cycle_hp')
abline(h=0, lty = 3)
base = cbind(divida,do.call(cbind, lapply(-24-0:3, function(x) lag(divida, x))))
colnames(base) = c('desemp', paste('L',0:3,sep=''))
model = lm(desemp~., data = base)
base = cbind(base, 'hamilton_cycle' =base[,1]- predict(model, base))
plot(window(base[,"hamilton_cycle"],start=c(2004,01),end=c(2021,12)), ylab='cycle_hamilton', main = 'Hamitlon')
abline(h=0,lty =3)
#Decompondo séries de tempo
#Fixando pasta com arquivos
setwd("~/Documentos/GitHub/Econometria-III/codigos/")
#Carregando pacotes necessários. Instale-os se não os possuir
library(forecast) #Pacote forecast para métodos de previsão
library(sandwich) #Erros padrão HAC
library(lmtest) #Testes com erros padrão robustos
#Carregando dados
data = read.csv2("Raiz_Unitaria/divida_liquida.csv")
divida = ts(data = data$Divida.liquida.do.Setor.publico, start = c(2001,12), frequency = 12)
plot(divida)
#Da aula anterior, sabemos que a série apresenta raiz unitária, e de:
trend = 1:(length(divida)-1)
regg = lm(diff(divida)~trend)
coeftest(regg, vcov. = vcovHAC)
#Série não apresenta componentes determinísticos na primeira diferença.
#Dessa forma, estimaremos o ARMA em primeiras diferenças (ARIMA(p,1,q)) sem intercepto ou tendência.
#FAC e FACP do processo estacionarizado (no nosso caso, basta tirar as diferenças,
#pois n há não estacionariedade determinística uma vez que o processo é diferenciado)
acf(diff(divida), lag.max = 40)
pacf(diff(divida), lag.max = 40)
#Da inspeção visual da FAC e FACP, o processo parece ser compatível com MA(2)
#No entanto, FACP, apesar de aparentemente exibir decaimento, poderia ser compatível com um componente
#AR(12)
#Vamos ser conservadores e considerar pmax = 12 e qmax = 2, e calcular todos os modelos:
pmax = 12
qmax = 2
#Vamos usar uma função auxiliar, que incluí no arquivo box_jenkins_parallel.R
source("Box_jenkins/box_jenkins_parallel.R")
tabela = arima.est.parallel(divida, pmax, qmax, d=1, include.constant = F, include.trend = F,
signif = 0.1, lags.lbox = c(20,30))
#Removendo modelos que não convergiram
tabela = tabela[tabela$Converged,]
#MA(2) e ARMA(5,2) parecem razoáveis. Vamos estimá-lo:
modelo = Arima(divida, order =c(0,1,2), include.constant = F, include.drift = F)
summary(modelo)
checkresiduals(modelo)
forecast(modelo)
plot(forecast(modelo))
# ARMA(5,2)
modelo2 = Arima(divida, order =c(5,1,2), include.constant = F, include.drift = F)
summary(modelo2)
checkresiduals(modelo2)
forecast(modelo2)
plot(forecast(modelo2))
#Resultados parecidos: vamos ficar com o modelo mais parcimonioso
#Vamos usar o modelo para calcular a decomposição de beveridge Nelson
#Vamos fazer a decomposição a partir de Jan/2003
lp =c()
for(year in 2004:2023)
for(month in 1:12)
{
valor = forecast(Arima(window(divida,end=c(year,month)), model = modelo), h=1000)
lp = c(lp,valor$mean[1000])
}
lp = ts(lp, start = c(2004,1),frequency=12)
cycle_bn = divida - lp
plot(cycle_bn, main = 'Beveridge-Nelson')
abline(h=0, lty = 3)
cycle_hp =   mFilter::hpfilter(divida,129600,type = "lambda")$cycle
plot(window(cycle_hp,start =c(2004,01)), main = 'Filtro HP', xlab='cycle_hp')
abline(h=0, lty = 3)
base = cbind(divida,do.call(cbind, lapply(-24-0:3, function(x) lag(divida, x))))
colnames(base) = c('desemp', paste('L',0:3,sep=''))
model = lm(desemp~., data = base)
base = cbind(base, 'hamilton_cycle' =base[,1]- predict(model, base))
plot(window(base[,"hamilton_cycle"],start=c(2004,01),end=c(2021,12)), ylab='cycle_hamilton', main = 'Hamilton')
abline(h=0,lty =3)
